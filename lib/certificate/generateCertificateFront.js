// lib/certificate/generateCertificateFront.js
import PDFDocument from "pdfkit";
import { readFile } from "fs/promises";
import path from "path";

async function toImageBuffer(src) {
  try {
    let input =
      src || process.env.CERT_FRONT_URL || "templates/cert-front.jpeg";

    // data URL
    if (typeof input === "string" && input.startsWith("data:")) {
      const m = input.match(/^data:(.*?);base64,(.*)$/);
      if (m?.[2]) return Buffer.from(m[2], "base64");
    }
    // http(s)
    if (/^https?:\/\//i.test(input)) {
      const res = await fetch(input);
      if (!res.ok) throw new Error(`Fetch failed ${res.status}`);
      const ab = await res.arrayBuffer();
      return Buffer.from(ab);
    }
    // absolute
    if (path.isAbsolute(input)) return await readFile(input);

    // relative â†’ cari di public/
    const rel = input.replace(/^\//, "");
    const candidates = [
      rel.startsWith("public/")
        ? path.join(process.cwd(), rel)
        : path.join(process.cwd(), "public", rel),
      path.join(process.cwd(), rel),
    ];
    for (const p of candidates) {
      try {
        return await readFile(p);
      } catch {}
    }
    throw new Error(`File not found for: ${input}`);
  } catch (e) {
    console.warn("[CERT] toImageBuffer fallback:", e?.message || e);
    return null;
  }
}

async function toFontBuffer(src) {
  try {
    if (!src) return null;
    if (Buffer.isBuffer(src)) return src;
    if (src instanceof Uint8Array) return Buffer.from(src);
    if (typeof src !== "string") return null;

    const candidate = path.isAbsolute(src)
      ? src
      : path.join(process.cwd(), src.replace(/^\.\//, ""));

    return await readFile(candidate);
  } catch (e) {
    console.warn("[CERT] toFontBuffer failed:", e?.message || e);
    return null;
  }
}

function drawFitLine(
  doc,
  text,
  { x, y, width, max = 90, min = 28, align = "center", font = "Helvetica-Bold" }
) {
  if (font) doc.font(font);
  let size = max;
  while (size > min) {
    doc.fontSize(size);
    const w = doc.widthOfString(text || "");
    if (w <= width) break;
    size -= 1.5;
  }
  doc.text(text || "", x, y, { width, align });
}

export async function generateCertificateFront({
  fullName,
  noCertificate,
  templateImagePathFront,
  // opsional: fontPath { bold, italic, regular }
  fontPath = {},
}) {
  const doc = new PDFDocument({
    size: "A4",
    layout: "landscape",
    margin: 0,
    font: null, // hindari font standar bawaan yang butuh file AFM
  });

  const chunks = [];
  doc.on("data", (c) => chunks.push(c));
  const done = new Promise((res) =>
    doc.on("end", () => res(Buffer.concat(chunks)))
  );

  const fontNames = {
    bold: null,
    italic: null,
    regular: null,
  };

  await Promise.all(
    Object.entries(fontPath).map(async ([kind, src]) => {
      const buf = await toFontBuffer(src);
      if (buf) {
        const name = `CERT_${kind.toUpperCase()}`;
        doc.registerFont(name, buf);
        fontNames[kind] = name;
      }
    })
  );

  const W = doc.page.width;
  const H = doc.page.height;

  // Background
  const bg = await toImageBuffer(templateImagePathFront);
  if (bg) doc.image(bg, 0, 0, { width: W, height: H });

  // (mengikuti posisi versi jsPDF kamu: ~52% & ~72% dari tinggi A4 landscape)
  // Nama (besar)
  drawFitLine(doc, fullName || "Peserta", {
    x: W * 0.07,
    y: H * 0.525,
    width: W * 0.86,
    max: 110, // gede biar mirip "150px" canvas
    min: 28,
    align: "center",
    font: fontNames.bold || fontNames.regular || "Helvetica-Bold",
  });

  // NO sertifikat
  doc.font(fontNames.italic || fontNames.regular || fontNames.bold || "Helvetica");
  doc.fontSize(48); // mirip "100px" pada canvas
  doc
    .fillColor("#000")
    .text(`NO: ${noCertificate}`, 0, H * 0.725, { width: W, align: "center" });

  // Footer ringan (opsional)
  doc
    .font(fontNames.regular || fontNames.bold || fontNames.italic || "Helvetica")
    .fontSize(10)
    .fillColor("#666");
  doc.text(`Generated by system`, 12, H - 20);

  doc.end();
  return done; // Buffer
}
